<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiwanese Mahjong Solitaire vs ğŸ¤– Robot</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Roboto', Arial, sans-serif; 
            min-height: 100vh; overflow-x: hidden; position: relative;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #ff6b6b 100%);
        }
        
        #bg-pattern {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite; z-index: -1;
        }
        @keyframes drift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(1deg); }
            66% { transform: translate(-20px, 20px) rotate(-1deg); }
        }
        
        #game-container { display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; position: relative; z-index: 1; }
        
        #ui { text-align: center; color: #fff; margin: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); background: rgba(0,0,0,0.3); padding: 25px; border-radius: 20px; backdrop-filter: blur(10px); }
        h1 { font-size: 2.5em; margin-bottom: 10px; background: linear-gradient(45deg, #fff, #ffd700); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; }
        #status { font-size: 18px; margin: 10px 0; }
        button { padding: 12px 24px; font-size: 16px; margin: 5px; border: none; border-radius: 12px; background: linear-gradient(145deg, #28a745, #20c997); color: white; cursor: pointer; font-weight: bold; box-shadow: 0 6px 20px rgba(40,167,69,0.4); transition: all 0.3s; border: 2px solid rgba(255,255,255,0.3); }
        button:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(40,167,69,0.6); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        #game { display: grid; grid-template-columns: repeat(20, 1fr); gap: 3px; max-width: 900px; margin: 20px auto; position: relative; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 20px; }
        .tile { aspect-ratio: 1; background: linear-gradient(145deg, #f8f9fa, #e9ecef); border: 3px solid #495057; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; box-shadow: 0 6px 20px rgba(0,0,0,0.2); text-shadow: 1px 1px 1px rgba(255,255,255,0.8); }
        .tile::before { content: attr(data-pips); position: absolute; top: 3px; font-size: 12px; color: #666; font-weight: normal; }
        .tile.robot-selected { border-color: #ff6b6b !important; box-shadow: 0 0 30px rgba(255,107,107,0.8); animation: robot-glow 0.6s infinite alternate; }
        @keyframes robot-glow { 0% { box-shadow: 0 0 20px rgba(255,107,107,0.6); } 100% { box-shadow: 0 0 40px rgba(255,107,107,1); } }
        .tile.matched { visibility: hidden; animation: explode 0.6s; }
        .tile.open { border-color: #28a745; transform: scale(1.08) translateY(-8px); box-shadow: 0 12px 40px rgba(40,167,69,0.6); }
        .tile.disabled { opacity: 0.4; cursor: not-allowed; }
        @keyframes explode { to { transform: scale(0) rotate(180deg); opacity: 0; } }
        
        @media (max-width: 768px) { #game { grid-template-columns: repeat(18, 1fr); gap: 2px; } .tile { font-size: 20px; } }
        @media (max-width: 480px) { #game { grid-template-columns: repeat(16, 1fr); } }
    </style>
</head>
<body>
    <div id="bg-pattern"></div>
    
    <div id="game-container">
        <div id="ui">
            <h1>ğŸ€„ Taiwanese Mahjong vs ğŸ¤– Robot</h1>
            <div id="status">Waiting for player move...</div>
            <div id="moves">Moves: <span id="playerMoves">0</span> | Robot: <span id="robotMoves">0</span></div>
            <button id="robotToggle">ğŸš« Disable Robot</button>
            <button onclick="newGame()">ğŸ”„ New Game</button>
            <button onclick="hint()">ğŸ’¡ Hint</button>
        </div>
        <div id="game"></div>
    </div>

    <script>
        const taiwaneseTiles = ['ğŸ€‡','ğŸ€ˆ','ğŸ€‰','ğŸ€Š','ğŸ€‹','ğŸ€Œ','ğŸ€','ğŸ€','ğŸ€','ğŸ€™','ğŸ€š','ğŸ€›','ğŸ€œ','ğŸ€','ğŸ€','ğŸ€Ÿ','ğŸ€ ','ğŸ€¡','ğŸ€','ğŸ€‘','ğŸ€’','ğŸ€“','ğŸ€”','ğŸ€•','ğŸ€–','ğŸ€—','ğŸ€˜'];
        let board = [], openTiles = [], playerMoves = 0, robotMoves = 0, robotEnabled = true, robotTurn = false;
        
        function initBoard() {
            // FIXED: Proper pyramid layout counting exactly 144 tiles
            const pyramidLayout = [
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0], // 8 tiles
                [0,0,0,1,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0], // 12 tiles  
                [0,0,1,2,3,3,3,3,3,3,3,3,2,1,1,1,0,0,0,0], // 16 tiles
                [0,1,2,3,4,4,4,4,4,4,4,4,3,2,1,1,1,0,0,0], // 18 tiles
                [1,2,3,4,5,5,5,5,5,5,5,5,4,3,2,1,1,0,0,0], // 20 tiles
                [2,3,4,5,6,6,6,6,6,6,6,6,5,4,3,2,1,1,0,0], // 20 tiles
                [3,4,5,6,7,7,7,7,7,7,7,7,6,5,4,3,2,1,1,0], // 20 tiles
                [4,5,6,7,8,8,8,8,8,8,8,8,7,6,5,4,3,2,1,1]  // 20 tiles
            ];
            
            let tileDeck = [];
            for (let i = 0; i < 4; i++) tileDeck.push(...taiwaneseTiles); // 4 full sets = 144 tiles
            shuffle(tileDeck);
            
            let flatBoard = [];
            let tileIndex = 0;
            pyramidLayout.forEach(row => {
                row.forEach(hasTile => {
                    flatBoard.push(hasTile ? tileDeck[tileIndex++] : 0);
                });
            });
            
            // FIXED: Proper 2D board creation
            board = [];
            for (let i = 0; i < flatBoard.length; i += 20) {
                board.push(flatBoard.slice(i, i + 20));
            }
            renderBoard();
        }
        
        function shuffle(array) { 
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array; 
        }
        
        function renderBoard() {
            const gameEl = document.getElementById('game');
            gameEl.innerHTML = '';
            board.forEach((row, y) => {
                row.forEach((tile, x) => {
                    const tileEl = document.createElement('div');
                    if (tile) {
                        tileEl.className = 'tile';
                        tileEl.textContent = tile;
                        tileEl.dataset.pips = getPips(tile);
                        tileEl.onclick = () => selectTile(x, y, false);
                    } else {
                        tileEl.className = 'tile empty';
                        tileEl.style.opacity = '0.1';
                    }
                    gameEl.appendChild(tileEl);
                });
            });
            updateDisabled();
        }
        
        function getPips(tile) {
            const pips = {'ğŸ€‡':'1','ğŸ€ˆ':'2','ğŸ€‰':'3','ğŸ€Š':'4','ğŸ€‹':'5','ğŸ€Œ':'6','ğŸ€':'7','ğŸ€':'8','ğŸ€':'9','ğŸ€™':'1','ğŸ€š':'2','ğŸ€›':'3','ğŸ€œ':'4','ğŸ€':'5','ğŸ€':'6','ğŸ€Ÿ':'7','ğŸ€ ':'8','ğŸ€¡':'9'};
            return pips[tile] || '';
        }
        
        function selectTile(x, y, isRobot = false) {
            if (!board[y] || !board[y][x] || openTiles.some(([ox, oy]) => ox === x && oy === y) || !isFree(x, y)) return;
            
            const tile = board[y][x];
            const tileEl = document.querySelectorAll('.tile')[y * 20 + x];
            openTiles.push([x, y]);
            tileEl.classList.add('open');
            
            if (isRobot) tileEl.classList.add('robot-selected');
            
            if (openTiles.length === 2) {
                const [[x1, y1]] = openTiles;
                (isRobot ? robotMoves : playerMoves)++;
                updateUI();
                
                if (board[y1][x1] !== tile) {
                    setTimeout(() => closeMismatch(), 1000);
                } else {
                    setTimeout(() => matchSuccess(x, y, x1, y1), 1000);
                }
            }
            updateDisabled();
        }
        
        function robotMove() {
            if (!robotEnabled || openTiles.length > 0 || board.flat().filter(t => t).length < 2) return;
            
            for (let y1 = 0; y1 < board.length; y1++) {
                for (let x1 = 0; x1 < 20; x1++) {
                    if (board[y1] && board[y1][x1] && isFree(x1, y1)) {
                        for (let y2 = 0; y2 < board.length; y2++) {
                            for (let x2 = 0; x2 < 20; x2++) {
                                if ((x2 !== x1 || y2 !== y1) && board[y2] && board[y2][x2] === board[y1][x1] && isFree(x2, y2)) {
                                    robotTurn = true;
                                    selectTile(x1, y1, true);
                                    setTimeout(() => {
                                        if (openTiles.length === 1) selectTile(x2, y2, true);
                                    }, 500);
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function closeMismatch() {
            openTiles.forEach(([x, y]) => {
                const tileEl = document.querySelectorAll('.tile')[y * 20 + x];
                tileEl.classList.remove('open', 'robot-selected');
            });
            openTiles = []; robotTurn = false; updateDisabled();
            if (robotEnabled) setTimeout(robotMove, 1000);
        }
        
        function matchSuccess(x2, y2, x1, y1) {
            [[x1,y1],[x2,y2]].forEach(([x,y]) => {
                board[y][x] = 0;
                const tileEl = document.querySelectorAll('.tile')[y * 20 + x];
                tileEl.classList.add('matched');
            });
            openTiles = []; robotTurn = false; checkWin(); updateDisabled();
            if (robotEnabled && !checkWin()) setTimeout(robotMove, 1500);
        }
        
        function isFree(x, y) {
            if (!board[y]) return false;
            const leftFree = x === 0 || board[y][x-1] === 0;
            const rightFree = x === 19 || board[y][x+1] === 0;
            const topFree = y === 0 || board[y-1][x] === 0;
            return (leftFree || rightFree) && topFree;
        }
        
        function updateDisabled() {
            document.querySelectorAll('.tile').forEach((el, i) => {
                const x = i % 20, y = Math.floor(i / 20);
                if (board[y]?.[x] && !el.classList.contains('open') && !el.classList.contains('matched')) {
                    el.classList.toggle('disabled', !isFree(x, y));
                }
            });
        }
        
        function updateUI() {
            document.getElementById('playerMoves').textContent = playerMoves;
            document.getElementById('robotMoves').textContent = robotMoves;
            document.getElementById('status').textContent = robotTurn ? 'ğŸ¤– Robot thinking...' : 'ğŸ‘¤ Your turn';
        }
        
        function checkWin() {
            if (board.flat().every(t => t === 0)) {
                setTimeout(() => alert(`ğŸ‰ Victory!\nYou: ${playerMoves} moves | Robot: ${robotMoves} moves`), 500);
                return true;
            }
            return false;
        }
        
        function toggleRobot() {
            robotEnabled = !robotEnabled;
            const btn = document.getElementById('robotToggle');
            btn.textContent = robotEnabled ? 'ğŸš« Disable Robot' : 'â–¶ï¸ Enable Robot';
            if (robotEnabled) setTimeout(robotMove, 1000);
        }
        
        function newGame() {
            playerMoves = robotMoves = 0; openTiles = []; robotTurn = false; robotEnabled = true;
            document.getElementById('robotToggle').textContent = 'ğŸš« Disable Robot';
            initBoard(); updateUI();
        }
        
        function hint() {
            for (let y1 = 0; y1 < board.length; y1++) for (let x1 = 0; x1 < 20; x1++) {
                if (board[y1]?.[x1] && isFree(x1, y1)) for (let y2 = 0; y2 < board.length; y2++) for (let x2 = 0; x2 < 20; x2++) {
                    if ((x2 !== x1 || y2 !== y1) && board[y2]?.[x2] === board[y1][x1] && isFree(x2, y2)) {
                        document.querySelectorAll('.tile')[y1*20 + x1].style.boxShadow = '0 0 30px #ffd700';
                        setTimeout(() => document.querySelectorAll('.tile')[y1*20 + x1].style.boxShadow = '', 2000);
                        return;
                    }
                }
            }
            alert('No available matches!');
        }
        
        // Initialize everything
        document.getElementById('robotToggle').onclick = toggleRobot;
        initBoard();
        updateUI();
        setTimeout(() => { if (robotEnabled) robotMove(); }, 2000);
    </script>
</body>
</html>

