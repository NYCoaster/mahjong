<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mahjong v5: Master Logic</title>
    <style>
        :root {
            --bg-color: #2d5e3e;
            --table-border: #5c3a21;
            --tile-bg: #fff;
            --tile-color: #000;
            --tile-border: #999;
        }

        body {
            margin: 0;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- UI LAYERS --- */
        .screen {
            position: absolute; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .hidden { display: none !important; }

        h1 { font-size: 4em; color: gold; text-shadow: 0 0 20px orange; margin-bottom: 20px; }
        
        .menu-btn {
            padding: 15px 40px; margin: 10px;
            font-size: 24px; background: #444;
            color: white; border: 2px solid #666;
            cursor: pointer; transition: all 0.2s;
            width: 300px; text-align: center;
            border-radius: 8px;
        }
        .menu-btn:hover { background: gold; color: black; transform: scale(1.05); }

        /* --- GAME TABLE --- */
        #game-table {
            position: relative; width: 900px; height: 900px;
            border: 15px solid var(--table-border);
            border-radius: 40px; background: var(--bg-color);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
            display: none;
        }

        /* --- HUD --- */
        #hud-top {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0,0,0,0.6); padding: 8px 20px;
            border-radius: 25px; font-size: 20px; border: 1px solid #555;
        }

        /* --- NOTIFICATIONS --- */
        #center-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100;
            text-align: center; width: 100%;
        }
        #big-msg {
            font-size: 6em; font-weight: 900; color: gold;
            text-shadow: 5px 5px 0 #000, 0 0 30px red;
            opacity: 0; transition: opacity 0.2s;
            transform: scale(0.5); transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #big-msg.show {
            opacity: 1; transform: scale(1);
        }

        /* --- ACTION BAR --- */
        #actions {
            position: absolute; top: 58%; left: 50%;
            transform: translate(-50%, -50%);
            display: none; gap: 15px; z-index: 150;
        }
        .action-btn {
            padding: 15px 30px; font-size: 22px; font-weight: bold;
            border: 3px solid white; border-radius: 10px;
            cursor: pointer; box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        .btn-hu { background: #ff0000; color: white; animation: pulse 1s infinite; }
        .btn-kong { background: #ffcc00; color: black; }
        .btn-pung { background: #00ccff; color: black; }
        .btn-chow { background: #00ff99; color: black; }
        .btn-skip { background: #999; color: white; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* --- TILES --- */
        .tile {
            width: 42px; height: 58px;
            background: var(--tile-bg); color: var(--tile-color);
            border: 1px solid var(--tile-border); border-radius: 4px;
            display: flex; justify-content: center; align-items: center;
            font-size: 36px; box-shadow: 2px 4px 6px rgba(0,0,0,0.4);
            position: relative; user-select: none;
        }
        .tile-back {
            background: #1a6b36; border: 1px solid #4da36e;
            color: rgba(255,255,255,0.2);
        }

        /* --- LAYOUTS --- */
        .hand-container { position: absolute; display: flex; gap: 12px; }
        .exposed-tiles { display: flex; gap: 8px; }
        .hand-tiles { display: flex; gap: 2px; }
        .meld { 
            display: flex; gap: 1px; padding: 4px; 
            background: rgba(0,0,0,0.2); border-radius: 6px; 
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Player 0 (Human) */
        #p0-area { bottom: 30px; left: 50%; transform: translateX(-50%); align-items: flex-end; }
        #p0-hand .tile { cursor: pointer; transition: transform 0.2s; }
        #p0-hand .tile:hover { transform: translateY(-15px); border-color: gold; z-index: 10; }

        /* Bots */
        #p1-area { right: 40px; top: 50%; transform: translateY(-50%); flex-direction: column-reverse; align-items: flex-end; }
        #p1-hand, #p1-exposed { flex-direction: column; }
        #p1-area .tile { transform: rotate(-90deg); width: 58px; height: 42px; }

        #p2-area { top: 30px; left: 50%; transform: translateX(-50%); flex-direction: row-reverse; align-items: flex-start; }
        #p2-area .tile { transform: rotate(180deg); }

        #p3-area { left: 40px; top: 50%; transform: translateY(-50%); flex-direction: column; align-items: flex-start; }
        #p3-hand, #p3-exposed { flex-direction: column; }
        #p3-area .tile { transform: rotate(90deg); width: 58px; height: 42px; }

        #discard-pile {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            display: grid; grid-template-columns: repeat(12, 1fr);
            gap: 4px;
        }
    </style>
</head>
<body>

<!-- MENU -->
<div id="main-menu" class="screen">
    <h1>MAHJONG LEGENDS</h1>
    <div style="margin-bottom:20px; color:#aaa">v5.0: Kong & Win Update</div>
    <button class="menu-btn" onclick="startGame()">START GAME</button>
</div>

<!-- GAME -->
<div id="game-table">
    <div id="hud-top">
        Tiles: <span id="wall-count">0</span> | 
        Status: <span id="status-txt" style="color:gold">Waiting</span>
    </div>

    <div id="center-overlay">
        <div id="big-msg">ACTION!</div>
    </div>

    <div id="discard-pile"></div>

    <!-- ACTION BAR -->
    <div id="actions">
        <button id="btn-hu" class="action-btn btn-hu" onclick="doWin()">HU (WIN)!</button>
        <button id="btn-kong" class="action-btn btn-kong" onclick="doKong()">KONG</button>
        <button id="btn-pung" class="action-btn btn-pung" onclick="doPung()">PUNG</button>
        <button id="btn-chow" class="action-btn btn-chow" onclick="doChow()">CHOW</button>
        <button class="action-btn btn-skip" onclick="skipAction()">PASS</button>
    </div>

    <!-- PLAYERS -->
    <div id="p0-area" class="hand-container">
        <div id="p0-exposed" class="exposed-tiles"></div>
        <div id="p0-hand" class="hand-tiles"></div>
    </div>
    <div id="p1-area" class="hand-container">
        <div id="p1-exposed" class="exposed-tiles"></div>
        <div id="p1-hand" class="hand-tiles"></div>
    </div>
    <div id="p2-area" class="hand-container">
        <div id="p2-exposed" class="exposed-tiles"></div>
        <div id="p2-hand" class="hand-tiles"></div>
    </div>
    <div id="p3-area" class="hand-container">
        <div id="p3-exposed" class="exposed-tiles"></div>
        <div id="p3-hand" class="hand-tiles"></div>
    </div>
</div>

<script>
    /* --- CORE DATA --- */
    const TILE_MAP = {
        'east': 0x1F000, 'south': 0x1F001, 'west': 0x1F002, 'north': 0x1F003,
        'red': 0x1F004, 'green': 0x1F005, 'white': 0x1F006,
        'chars': 0x1F007, 'bamboo': 0x1F010, 'dots': 0x1F019
    };

    let deck = [], players = [], exposed = [], discardPile = [];
    let turn = 0, lastDiscard = null, isPaused = false;

    /* --- INIT --- */
    function startGame() {
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('game-table').style.display = 'block';
        initRound();
    }

    function initRound() {
        deck = createDeck();
        players = [[], [], [], []];
        exposed = [[], [], [], []];
        discardPile = [];
        turn = 0;
        isPaused = false;
        
        // Deal 13 tiles (Standard) -> Dealer gets 14th
        for (let i = 0; i < 13; i++) for (let p = 0; p < 4; p++) players[p].push(deck.pop());
        
        // Dealer (Human) draws first
        drawTile(0);
    }

    function createDeck() {
        let d = [];
        ['chars','bamboo','dots'].forEach(type => { for(let i=1; i<=9; i++) for(let k=0; k<4; k++) d.push({type, val: i}); });
        ['east','south','west','north','red','green','white'].forEach(val => { for(let k=0; k<4; k++) d.push({type: 'honor', val}); });
        return d.sort(() => Math.random() - 0.5);
    }

    /* --- GAME LOOP --- */
    function drawTile(pid) {
        if (deck.length === 0) return alert("Wall Empty - Draw!");
        
        const tile = deck.pop();
        players[pid].push(tile);
        updateUI();

        if (pid === 0) {
            updateStatus("Your Turn");
            checkSelfActions(); // Check for Zimo (Self-Draw Win) or Concealed Kong
        } else {
            updateStatus(`Bot ${pid} Thinking...`);
            setTimeout(() => botTurn(pid), 1000);
        }
    }

    function botTurn(pid) {
        // 1. Check Win on Draw (Zimo)
        if (checkWinAlgorithm(players[pid])) {
            announceAction(pid, "HU! (Zimo)", 3000, () => endGame(pid));
            return;
        }
        // 2. Check Concealed Kong
        // (Simplified: Bots skip concealed kong for speed, only discard)
        
        // 3. Discard
        const idx = Math.floor(Math.random() * players[pid].length);
        discardTile(pid, idx);
    }

    function discardTile(pid, idx) {
        const tile = players[pid].splice(idx, 1)[0];
        lastDiscard = { tile, from: pid };
        discardPile.push(tile);
        updateUI();

        // INTERRUPT PHASE: Check if anyone else wants this tile
        checkInterrupts(tile, pid);
    }

    /* --- INTERRUPT ENGINE --- */
    function checkInterrupts(tile, fromPid) {
        // PRIORITY 1: HUMAN ACTIONS
        if (fromPid !== 0) {
            const canWin = checkWinAlgorithm([...players[0], tile]);
            const canKong = checkKong(players[0], tile);
            const canPung = checkPung(players[0], tile);
            const canChow = (fromPid === 3) && checkChow(players[0], tile);

            if (canWin || canKong || canPung || canChow) {
                isPaused = true;
                showActionButtons(canWin, canKong, canPung, canChow);
                return; // Wait for input
            }
        }

        // PRIORITY 2: BOT ACTIONS (With 3s Delay)
        let actingBot = -1;
        let actionType = "";

        // Check Bots (1, 2, 3) - Order doesn't matter for simple version
        for (let i = 1; i < 4; i++) {
            if (i === fromPid) continue;
            
            // Cheat: Give bots 10% chance to Pung/Kong if they have pairs
            // Real Logic: Check actual hand
            if (checkWinAlgorithm([...players[i], tile])) {
                actingBot = i; actionType = "HU!"; break;
            }
            if (checkKong(players[i], tile) && Math.random() > 0.5) {
                actingBot = i; actionType = "KONG!"; break;
            }
            if (checkPung(players[i], tile) && Math.random() > 0.7) {
                actingBot = i; actionType = "PUNG!"; break;
            }
        }

        if (actingBot > -1) {
            isPaused = true;
            // 3 SECOND DELAY MANDATE
            announceAction(actingBot, actionType, 3000, () => {
                performBotAction(actingBot, actionType, tile);
            });
        } else {
            // No interrupts, next player draws
            advanceTurn(fromPid);
        }
    }

    function performBotAction(pid, type, tile) {
        discardPile.pop(); // Take tile
        if (type === "HU!") {
             players[pid].push(tile);
             endGame(pid);
        } else if (type === "KONG!") {
            // Remove 3, Add tile, Exposed
            removeFromHand(pid, tile, 3);
            exposed[pid].push([tile, tile, tile, tile]);
            drawTile(pid); // Kong draws replacement
        } else if (type === "PUNG!") {
            removeFromHand(pid, tile, 2);
            exposed[pid].push([tile, tile, tile]);
            // After Pung, must discard, not draw
            setTimeout(() => {
                 // Bot discards a random tile after Pung
                 const discardIdx = Math.floor(Math.random() * players[pid].length);
                 discardTile(pid, discardIdx);
            }, 1000);
        }
    }

    function advanceTurn(currentPid) {
        const next = (currentPid + 1) % 4;
        drawTile(next);
    }

    /* --- HUMAN INTERACTION --- */
    function checkSelfActions() {
        // Check Zimo (Win on self draw)
        if (checkWinAlgorithm(players[0])) {
            document.getElementById('actions').style.display = 'flex';
            document.getElementById('btn-hu').style.display = 'block';
            // Hide others
            ['kong','pung','chow'].forEach(id => document.getElementById('btn-'+id).style.display='none');
            isPaused = true;
        }
        // Logic for concealed Kong could go here
    }

    function showActionButtons(win, kong, pung, chow) {
        const bar = document.getElementById('actions');
        bar.style.display = 'flex';
        document.getElementById('btn-hu').style.display = win ? 'block' : 'none';
        document.getElementById('btn-kong').style.display = kong ? 'block' : 'none';
        document.getElementById('btn-pung').style.display = pung ? 'block' : 'none';
        document.getElementById('btn-chow').style.display = chow ? 'block' : 'none';
    }

    // Human Commands
    window.doWin = function() {
        if (lastDiscard && lastDiscard.from !== 0) players[0].push(lastDiscard.tile);
        endGame(0);
    };

    window.doPung = function() {
        const t = lastDiscard.tile;
        discardPile.pop();
        removeFromHand(0, t, 2);
        exposed[0].push([t,t,t]);
        finishInterrupt(); // Now discard
    };

    window.doKong = function() {
        const t = lastDiscard.tile;
        discardPile.pop();
        removeFromHand(0, t, 3);
        exposed[0].push([t,t,t,t]);
        drawTile(0); // Draw replacement
        hideActions();
    };

    window.doChow = function() {
        const t = lastDiscard.tile;
        discardPile.pop();
        // Find combo (Simplified)
        const h = players[0];
        const t1 = h.find(x=>x.type===t.type && x.val===t.val-1);
        const t2 = h.find(x=>x.type===t.type && x.val===t.val+1);
        
        if(t1 && t2) {
            removeSpecific(0, t1); removeSpecific(0, t2);
            exposed[0].push([t1, t, t2].sort((a,b)=>a.val-b.val));
            finishInterrupt();
        }
    };

    window.skipAction = function() {
        hideActions();
        isPaused = false;
        advanceTurn(lastDiscard.from);
    };

    function finishInterrupt() {
        hideActions();
        updateUI();
        updateStatus("Action Complete. Discard.");
        isPaused = false;
        turn = 0; // Human turn to discard
    }

    function hideActions() { document.getElementById('actions').style.display = 'none'; }

    /* --- VISUALS --- */
    function announceAction(pid, text, delay, callback) {
        const el = document.getElementById('big-msg');
        el.innerText = pid === 0 ? text : `BOT ${pid}\n${text}`;
        el.classList.add('show');
        updateStatus(`Bot ${pid} is triggering ${text}...`);
        
        setTimeout(() => {
            el.classList.remove('show');
            callback();
        }, delay);
    }

    function endGame(winnerPid) {
        const name = winnerPid === 0 ? "YOU" : `BOT ${winnerPid}`;
        document.getElementById('big-msg').innerHTML = `${name} WON!`;
        document.getElementById('big-msg').classList.add('show');
        isPaused = true;
        setTimeout(() => {
            alert(`Game Over! Winner: ${name}`);
            location.reload();
        }, 2000);
    }

    function updateStatus(msg) {
        document.getElementById('status-txt').innerText = msg;
        document.getElementById('wall-count').innerText = deck.length;
    }

    /* --- LOGIC HELPERS --- */
    function checkPung(hand, tile) { return hand.filter(x => isSame(x, tile)).length >= 2; }
    function checkKong(hand, tile) { return hand.filter(x => isSame(x, tile)).length >= 3; }
    function checkChow(hand, tile) {
        if (tile.type === 'honor') return false;
        const has = (v) => hand.some(x => x.type === tile.type && x.val === v);
        // Check neighbors (2-3 for 1, etc)
        const v = tile.val;
        return (has(v-1) && has(v+1)) || (has(v-1) && has(v-2)) || (has(v+1) && has(v+2));
    }

    // Basic Win Logic (4 Sets + 1 Pair)
    function checkWinAlgorithm(hand) {
        // Deep copy to avoid mutating
        let tiles = JSON.parse(JSON.stringify(hand));
        tiles.sort((a,b) => getVal(a) - getVal(b));

        // Recursive checker is too heavy for this snippets, implementing basic pair check
        // Must have 14 tiles (or 13+1)
        if (tiles.length % 3 !== 2) return false;

        // Simple heuristic for "Likely Win" (Pairs + Triples)
        // A proper Mahjong algorithm requires backtracking recursion
        // This is a placeholder logic that checks if we have mostly sets
        let pairs = 0;
        let sets = 0;
        
        // Count duplicates
        let counts = {};
        tiles.forEach(t => {
            const key = t.type + t.val;
            counts[key] = (counts[key] || 0) + 1;
        });
        
        // Very basic win check: All tiles must be part of a set (3) or the pair (2)
        // This is simplified. It assumes standard hands.
        let orphan = 0;
        for (let k in counts) {
            let c = counts[k];
            if (c === 2) pairs++;
            else if (c === 3 || c === 4) sets++;
            else orphan++;
        }
        return (orphan === 0 && pairs === 1);
    }

    /* --- UTILS --- */
    function isSame(a, b) { return a.type === b.type && a.val === b.val; }
    function removeFromHand(pid, t, n) {
        let count = 0;
        players[pid] = players[pid].filter(x => {
            if(count < n && isSame(x, t)) { count++; return false; }
            return true;
        });
    }
    function removeSpecific(pid, t) {
        const i = players[pid].findIndex(x => isSame(x,t));
        if (i>-1) players[pid].splice(i,1);
    }
    function getVal(t) {
        const s = {'chars':100, 'dots':200, 'bamboo':300, 'honor':400};
        let v = typeof t.val === 'string' ? ['east','south','west','north','red','green','white'].indexOf(t.val) : t.val;
        return (s[t.type]||0) + v;
    }
    function getChar(t) {
        if (t.type === 'honor') return String.fromCodePoint(TILE_MAP[t.val]);
        return String.fromCodePoint(TILE_MAP[t.type] + (t.val - 1));
    }

    /* --- RENDER --- */
    function updateUI() {
        document.getElementById('discard-pile').innerHTML = '';
        discardPile.forEach(t => document.getElementById('discard-pile').appendChild(createTile(t)));

        [0,1,2,3].forEach(pid => {
            const hDiv = document.getElementById(`p${pid}-hand`);
            const eDiv = document.getElementById(`p${pid}-exposed`);
            hDiv.innerHTML = ''; eDiv.innerHTML = '';
            
            exposed[pid].forEach(m => {
                const d = document.createElement('div'); d.className='meld';
                m.forEach(t => { let el=createTile(t); el.style.background='#ddd'; d.appendChild(el); });
                eDiv.appendChild(d);
            });

            players[pid].forEach((t, i) => {
                if (pid===0) {
                    let el = createTile(t);
                    el.onclick = () => { if(!isPaused && turn===0) discardTile(0, i); };
                    hDiv.appendChild(el);
                } else {
                    let el = document.createElement('div');
                    el.className='tile tile-back'; el.innerText='ðŸ€«';
                    hDiv.appendChild(el);
                }
            });
        });
    }
    function createTile(t) {
        let d = document.createElement('div');
        d.className = `tile ${t.type}`; d.innerText = getChar(t);
        return d;
    }
</script>
</body>
</html>
