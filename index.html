<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Taiwanese Mahjong â€“ With Bots</title>
  <style>
    body {
      margin: 0;
      background: #003300;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    nav {
      background: #001a00;
      padding: 8px 12px;
      display: flex;
      gap: 8px;
    }
    nav button {
      padding: 4px 10px;
      border: none;
      border-radius: 3px;
      background: #228822;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    nav button.active {
      background: #ffaa00;
      color: #000;
    }
    section {
      display: none;
      padding: 12px;
    }
    section.active {
      display: block;
    }
    #home-section {
      max-width: 600px;
      line-height: 1.4;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 4px;
      z-index: 10;
      font-size: 14px;
    }
    #achievements-list {
      margin: 4px 0 0;
      padding-left: 18px;
      max-height: 120px;
      overflow-y: auto;
      font-size: 13px;
    }
    #btn-next-hand {
      margin-top: 6px;
      padding: 4px 8px;
      background: #ffaa00;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #canvas {
      display: block;
      background: #006020;
    }
    #achievements-page-list {
      list-style: disc;
      padding-left: 20px;
      max-width: 600px;
    }
  </style>
</head>
<body>

<nav>
  <button id="nav-home" class="active">Home</button>
  <button id="nav-game">Game</button>
  <button id="nav-achievements">Achievements</button>
</nav>

<section id="home-section" class="active">
  <h1>Taiwanese Mahjong</h1>
  <p>
    Play against 3 robots. You only see <strong>one</strong> of your tiles;
    the rest are blank. Bots get smarter as your level rises, and you can
    level up or level down based on wins and losses.
  </p>
  <p>
    Go to the <strong>Game</strong> tab to start. Click a tile at the bottom
    to discard; click above your hand to change which tile is visible.
  </p>
</section>

<section id="game-section">
  <div id="game-container">
    <div id="ui">
      <div>Level: <span id="level">1</span></div>
      <div>XP: <span id="xp">0</span></div>
      <div>Hands Played: <span id="hands-played">0</span></div>
      <div>Wins: <span id="wins">0</span></div>
      <div>Achievements:</div>
      <ul id="achievements-list"></ul>
      <button id="btn-next-hand">Next Hand</button>
    </div>
    <canvas id="canvas" width="1280" height="720"></canvas>
  </div>
</section>

<section id="achievements-section">
  <h2>Achievements</h2>
  <p>These are the achievements you can earn:</p>
  <ul id="achievements-page-list">
    <li><strong>First Win</strong> â€“ Win your very first hand.</li>
    <li><strong>Big Hand</strong> â€“ Win a hand with high tai (placeholder logic).</li>
    <li><strong>Self Draw</strong> â€“ Win by drawing your own winning tile.</li>
    <li><strong>Flower Power</strong> â€“ Win with 4+ flowers in your hand.</li>
    <li><strong>Three in a Row</strong> â€“ Win 3 hands in a row.</li>
    <li><strong>Ten Wins</strong> â€“ Win 10 total hands.</li>
    <li><strong>Persistent</strong> â€“ Play 20 hands total.</li>
    <li><strong>Comeback Kid</strong> â€“ Win a hand after losing 3 in a row.</li>
    <li><strong>Solo Vision</strong> â€“ Win a hand while only one tile was visible.</li>
  </ul>
  <p>Unlocked achievements will highlight in yellow.</p>
</section>

<script>
  // ---------- Page navigation ----------
  const navHome = document.getElementById("nav-home");
  const navGame = document.getElementById("nav-game");
  const navAchievements = document.getElementById("nav-achievements");

  const homeSection = document.getElementById("home-section");
  const gameSection = document.getElementById("game-section");
  const achievementsSection = document.getElementById("achievements-section");

  function setActivePage(page) {
    [navHome, navGame, navAchievements].forEach(btn => btn.classList.remove("active"));
    [homeSection, gameSection, achievementsSection].forEach(sec => sec.classList.remove("active"));

    if (page === "home") {
      navHome.classList.add("active");
      homeSection.classList.add("active");
    } else if (page === "game") {
      navGame.classList.add("active");
      gameSection.classList.add("active");
    } else if (page === "achievements") {
      navAchievements.classList.add("active");
      achievementsSection.classList.add("active");
    }
  }

  navHome.addEventListener("click", () => setActivePage("home"));
  navGame.addEventListener("click", () => setActivePage("game"));
  navAchievements.addEventListener("click", () => setActivePage("achievements"));

  // ---------- Mahjong + bots ----------
  const SUITS = ["dots", "bams", "craks"];
  const RANKS = [1,2,3,4,5,6,7,8,9];
  const WINDS = ["east", "south", "west", "north"];
  const DRAGONS = ["red", "green", "white"];
  const FLOWERS = ["flower1","flower2","flower3","flower4","season1","season2","season3","season4"];

  function createTile(kind, value) { return { kind, value }; }

  function buildWall() {
    const wall = [];
    for (const suit of SUITS) {
      for (const r of RANKS) {
        for (let i = 0; i < 4; i++) wall.push(createTile("suit", { suit, rank: r }));
      }
    }
    for (const w of WINDS) {
      for (let i = 0; i < 4; i++) wall.push(createTile("wind", w));
    }
    for (const d of DRAGONS) {
      for (let i = 0; i < 4; i++) wall.push(createTile("dragon", d));
    }
    for (const f of FLOWERS) wall.push(createTile("flower", f));
    for (let i = wall.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [wall[i], wall[j]] = [wall[j], wall[i]];
    }
    return wall;
  }

  function tileKey(t) {
    if (t.kind === "suit") return t.value.suit[0] + String(t.value.rank);
    return t.value;
  }

  function isBasicWin(handTiles) {
    const base = handTiles.filter(t => t.kind !== "flower");
    if (base.length !== 17) return false;
    const keys = base.map(tileKey).sort();
    const counts = {};
    for (const k of keys) counts[k] = (counts[k] || 0) + 1;

    const copyCounts = obj => JSON.parse(JSON.stringify(obj));

    for (const k in counts) {
      if (counts[k] < 2) continue;
      const test = copyCounts(counts);
      test[k] -= 2;
      if (test[k] === 0) delete test[k];
      if (canFormMelds(test)) return true;
    }
    return false;
  }

  function canFormMelds(counts) {
    const keys = Object.keys(counts);
    if (keys.length === 0) return true;

    const k = keys[0];
    const c = counts[k];

    if (c >= 3) {
      counts[k] -= 3;
      if (counts[k] === 0) delete counts[k];
      if (canFormMelds(counts)) return true;
      counts[k] = c;
    }

    if (["d","b","c"].includes(k[0])) {
      const suit = k[0];
      const rank = parseInt(k.slice(1), 10);
      if (rank <= 7) {
        const k2 = suit + (rank + 1);
        const k3 = suit + (rank + 2);
        if ((counts[k2] || 0) > 0 && (counts[k3] || 0) > 0) {
          const backup = Object.assign({}, counts);
          counts[k]--; counts[k2]--; counts[k3]--;
          [k,k2,k3].forEach(key => { if (counts[key] === 0) delete counts[key]; });
          if (canFormMelds(counts)) return true;
          Object.assign(counts, backup);
        }
      }
    }
    return false;
  }

  // ---- Level system with level up and level down ----
  const levelSystem = {
    level: 1,
    xp: 0,
    xpForNextLevel(level = this.level) {
      return 100 * level; // 100, 200, 300, ...
    },
    xForFullLevel(level) {
      return this.xpForNextLevel(level);
    },
    addXp(amount) {
      this.xp += amount;

      // Level up
      while (this.xp >= this.xpForNextLevel(this.level)) {
        this.xp -= this.xpForNextLevel(this.level);
        this.level++;
      }

      // Level down (not below 1)
      while (this.xp < 0 && this.level > 1) {
        this.level--;
        this.xp += this.xForFullLevel(this.level);
      }

      // Clamp at level 1
      if (this.level === 1 && this.xp < 0) this.xp = 0;
    }
  };

  const stats = {
    handsPlayed: 0,
    wins: 0,
    currentStreak: 0,
    loseStreak: 0
  };

  const achievementsState = {
    unlocked: new Set(),
    checkAfterHand(info) {
      const { playerWon, tai, selfDraw, flowersVisibleRule } = info;

      if (playerWon && !this.unlocked.has("First Win")) this.unlocked.add("First Win");
      if (playerWon && tai >= 8 && !this.unlocked.has("Big Hand")) this.unlocked.add("Big Hand");
      if (playerWon && selfDraw && !this.unlocked.has("Self Draw")) this.unlocked.add("Self Draw");
      if (playerWon && flowersVisibleRule && !this.unlocked.has("Flower Power")) this.unlocked.add("Flower Power");
      if (stats.currentStreak >= 3 && !this.unlocked.has("Three in a Row")) this.unlocked.add("Three in a Row");
      if (stats.wins >= 10 && !this.unlocked.has("Ten Wins")) this.unlocked.add("Ten Wins");
      if (stats.handsPlayed >= 20 && !this.unlocked.has("Persistent")) this.unlocked.add("Persistent");
      if (playerWon && stats.loseStreak >= 3 && !this.unlocked.has("Comeback Kid")) this.unlocked.add("Comeback Kid");
      if (playerWon && !this.unlocked.has("Solo Vision")) this.unlocked.add("Solo Vision");

      return Array.from(this.unlocked);
    }
  };

  // state.players = [player, bot1, bot2, bot3]
  let state;

  function createInitialState() {
    const wall = buildWall();
    const players = [];
    for (let i = 0; i < 4; i++) players.push([]);

    // 16 tiles each
    for (let n = 0; n < 16; n++) {
      for (let p = 0; p < 4; p++) {
        players[p].push(wall.pop());
      }
    }

    // dealer (player 0) draws one extra
    players[0].push(wall.pop());

    return {
      wall,
      players,
      discards: [],
      currentPlayer: 0,
      winner: null,
      winnerIsPlayer: false,
      tai: 0
    };
  }

  function drawTileForPlayer(state, playerIndex) {
    if (!state.wall.length) return;
    state.players[playerIndex].push(state.wall.pop());
  }

  function discardTileForPlayer(state, playerIndex, tileIndex) {
    const [tile] = state.players[playerIndex].splice(tileIndex, 1);
    state.discards.push({ tile, from: playerIndex });
  }

  function computeSimpleTai() { return 5; }

  function checkWinForPlayer(state, playerIndex) {
    const hand = state.players[playerIndex];
    if (isBasicWin(hand)) {
      state.winner = playerIndex;
      state.winnerIsPlayer = (playerIndex === 0);
      state.tai = computeSimpleTai();
    }
  }

  // ---- Bot evaluation and difficulty (uses levelSystem.level) ----
  function evaluateTileForBot(tile, hand) {
    if (tile.kind === "wind" || tile.kind === "dragon") {
      return 3;
    }
    if (tile.kind === "suit") {
      const r = tile.value.rank;
      if (r >= 4 && r <= 6) return 3;
      if (r === 1 || r === 9) return 1;
      return 2;
    }
    if (tile.kind === "flower") {
      return 0;
    }
    return 1;
  }

  function chooseDiscardIndexForBot(hand, difficulty) {
    if (hand.length === 0) return 0;

    if (difficulty <= 0) {
      return Math.floor(Math.random() * hand.length);
    }

    const scores = hand.map(t => evaluateTileForBot(t, hand));
    let worstIndexes = [];
    let maxScore = -Infinity;
    let minScore = Infinity;

    scores.forEach((s, i) => {
      if (s > maxScore) maxScore = s;
      if (s < minScore) minScore = s;
    });

    const bestIndexes = scores.map((s, i) => (s === maxScore ? i : null)).filter(i => i !== null);
    worstIndexes = scores.map((s, i) => (s === minScore ? i : null)).filter(i => i !== null);

    if (difficulty === 1) {
      const candidates = scores.map((s, i) => (s < maxScore ? i : null))
                               .filter(i => i !== null);
      if (candidates.length > 0) {
        return candidates[Math.floor(Math.random() * candidates.length)];
      }
      return worstIndexes[Math.floor(Math.random() * worstIndexes.length)];
    }

    return worstIndexes[Math.floor(Math.random() * worstIndexes.length)];
  }

  function botTurn(state, botIndex) {
    if (state.winner !== null) return;

    let difficulty = 0;
    if (levelSystem.level >= 3 && levelSystem.level <= 4) difficulty = 1;
    if (levelSystem.level >= 5) difficulty = 2;

    drawTileForPlayer(state, botIndex);
    checkWinForPlayer(state, botIndex);
    if (state.winner !== null) return;

    const hand = state.players[botIndex];
    const discardIndex = chooseDiscardIndexForBot(hand, difficulty);
    discardTileForPlayer(state, botIndex, discardIndex);
  }

  function fullRoundFromPlayer(state) {
    for (let i = 1; i < 4 && state.winner === null; i++) {
      botTurn(state, i);
    }
  }

  // ---------- Rendering ----------
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const TILE_W = 48;
  const TILE_H = 64;

  function emojiForTile(tile) {
    if (tile.kind === "suit") {
      const { suit, rank } = tile.value;
      if (suit === "dots") {
        const map = {1:"ðŸ€™",2:"ðŸ€š",3:"ðŸ€›",4:"ðŸ€œ",5:"ðŸ€",6:"ðŸ€ž",7:"ðŸ€Ÿ",8:"ðŸ€ ",9:"ðŸ€¡"};
        return map[rank] || "ðŸ€«";
      }
      if (suit === "bams") {
        const map = {1:"ðŸ€",2:"ðŸ€‘",3:"ðŸ€’",4:"ðŸ€“",5:"ðŸ€”",6:"ðŸ€•",7:"ðŸ€–",8:"ðŸ€—",9:"ðŸ€˜"};
        return map[rank] || "ðŸ€«";
      }
      if (suit === "craks") {
        const map = {1:"ðŸ€‡",2:"ðŸ€ˆ",3:"ðŸ€‰",4:"ðŸ€Š",5:"ðŸ€‹",6:"ðŸ€Œ",7:"ðŸ€",8:"ðŸ€Ž",9:"ðŸ€"};
        return map[rank] || "ðŸ€«";
      }
    }
    if (tile.kind === "wind") {
      const map = { east:"ðŸ€€", south:"ðŸ€", west:"ðŸ€‚", north:"ðŸ€ƒ" };
      return map[tile.value] || "ðŸ€«";
    }
    if (tile.kind === "dragon") {
      const map = { red:"ðŸ€„", green:"ðŸ€…", white:"ðŸ€†" };
      return map[tile.value] || "ðŸ€«";
    }
    if (tile.kind === "flower") return "ðŸŒ¸";
    return "ðŸ€«";
  }

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      this.beginPath();
      this.moveTo(x+r, y);
      this.lineTo(x+w-r, y);
      this.quadraticCurveTo(x+w, y, x+w, y+r);
      this.lineTo(x+w, y+h-r);
      this.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      this.lineTo(x+r, y+h);
      this.quadraticCurveTo(x, y+h, x, y+h-r);
      this.lineTo(x, y+r);
      this.quadraticCurveTo(x, y, x+r, y);
      this.closePath();
    };
  }

  let visibleIndex = 0;

  function drawTileRect(x, y, showEmoji, tile) {
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2;
    ctx.roundRect(x, y, TILE_W, TILE_H, 4);
    ctx.fill();
    ctx.stroke();

    if (showEmoji && tile) {
      const emoji = emojiForTile(tile);
      ctx.font = "32px Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#000000";
      ctx.fillText(emoji, x + TILE_W / 2, y + TILE_H / 2);
    }
  }

  function renderTable() {
    ctx.fillStyle = "#006020";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ffffff";
    ctx.font = "18px Arial";
    ctx.textAlign = "left";
    ctx.fillText("You vs 3 bots. Only ONE of your tiles is visible. Level can go up or down.", 20, 30);

    const botYPositions = [120, 220, 320];
    for (let b = 1; b < 4; b++) {
      const hand = state.players[b];
      const y = botYPositions[b-1];
      ctx.fillStyle = "#ffffff";
      ctx.font = "16px Arial";
      ctx.fillText("Bot " + b, 20, y + TILE_H / 2);
      const startX = 100;
      hand.forEach((_, i) => {
        const x = startX + i * (TILE_W + 2);
        drawTileRect(x, y, false, null);
      });
    }

    const playerHand = state.players[0];
    const startX = 100;
    const y = canvas.height - TILE_H - 40;
    playerHand.forEach((tile, i) => {
      const x = startX + i * (TILE_W + 4);
      drawTileRect(x, y, i === visibleIndex, tile);
    });

    ctx.strokeStyle = "#ffff00";
    ctx.lineWidth = 2;
    const hx = startX + visibleIndex * (TILE_W + 4);
    const hy = y;
    ctx.strokeRect(hx - 2, hy - 2, TILE_W + 4, TILE_H + 4);

    if (state.winner !== null) {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#ffff00";
      ctx.font = "48px Arial";
      ctx.textAlign = "center";
      const msg = state.winnerIsPlayer ? "YOU WIN!" : "BOT " + state.winner + " WINS";
      ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
      if (state.winnerIsPlayer) {
        ctx.font = "24px Arial";
        ctx.fillText("Tai: " + state.tai, canvas.width / 2, canvas.height / 2 + 40);
      }
    }
  }

  // ---------- UI + interaction ----------
  const levelLabel = document.getElementById("level");
  const xpLabel = document.getElementById("xp");
  const achievementsList = document.getElementById("achievements-list");
  const handsPlayedLabel = document.getElementById("hands-played");
  const winsLabel = document.getElementById("wins");

  canvas.addEventListener("click", evt => {
    if (state.winner !== null) return;

    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;

    const playerHand = state.players[0];
    const handY = canvas.height - TILE_H - 40;
    const startX = 100;

    if (y >= handY && y <= handY + TILE_H) {
      const index = Math.floor((x - startX) / (TILE_W + 4));
      if (index >= 0 && index < playerHand.length) {
        discardTileForPlayer(state, 0, index);
        fullRoundFromPlayer(state);
        if (state.winner !== null) {
          endHand();
        } else {
          drawTileForPlayer(state, 0);
          if (visibleIndex >= state.players[0].length) visibleIndex = state.players[0].length - 1;
        }
        renderTable();
        return;
      }
    }

    if (y < handY) {
      if (playerHand.length > 0) {
        visibleIndex = (visibleIndex + 1) % playerHand.length;
        renderTable();
      }
    }
  });

  document.getElementById("btn-next-hand").addEventListener("click", () => {
    startNewHand();
  });

  function endHand() {
    stats.handsPlayed++;

    if (state.winnerIsPlayer) {
      stats.wins++;
      stats.currentStreak++;
      stats.loseStreak = 0;

      const xpGain = state.tai * 20;
      levelSystem.addXp(xpGain);

      const unlocked = achievementsState.checkAfterHand({
        playerWon: true,
        tai: state.tai,
        selfDraw: true,
        flowersVisibleRule: true
      });
      updateUI(unlocked);
      updateAchievementsPage(unlocked);
    } else {
      stats.currentStreak = 0;
      stats.loseStreak++;

      // XP penalty that can cause level down
      const basePenalty = 15;
      const penalty = basePenalty + (levelSystem.level - 1) * 5;
      levelSystem.addXp(-penalty);

      updateUI();
    }
  }

  function startNewHand() {
    state = createInitialState();
    visibleIndex = 0;
    updateUI();
    renderTable();
  }

  function updateUI(unlockedList) {
    levelLabel.textContent = levelSystem.level;
    xpLabel.textContent = levelSystem.xp;
    handsPlayedLabel.textContent = stats.handsPlayed;
    winsLabel.textContent = stats.wins;
    if (unlockedList) {
      achievementsList.innerHTML = "";
      unlockedList.forEach(name => {
        const li = document.createElement("li");
        li.textContent = name;
        achievementsList.appendChild(li);
      });
    }
  }

  function updateAchievementsPage(unlockedList) {
    const lis = document.querySelectorAll("#achievements-page-list li");
    lis.forEach(li => {
      const name = li.textContent.split("â€“")[0].trim();
      if (unlockedList.includes(name)) {
        li.style.color = "#ffff00";
      }
    });
  }

  startNewHand();
</script>

</body>
</html>
